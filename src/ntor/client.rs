use crate::ntor::common::{Certificate, generate_private_public_key_pair, InitSessionMessage, InitSessionResponse, PrivatePublicKeyPair};
use hmac::{Hmac, Mac};
use sha2::{Digest, Sha256};
use wasm_bindgen::prelude::*;
use x25519_dalek::PublicKey;
use crate::ntor::common;
use web_sys::console;

#[wasm_bindgen(getter_with_clone)]
pub struct Client {
    ephemeral_key_pair: PrivatePublicKeyPair,
    shared_secret: Option<Vec<u8>>,
}

#[wasm_bindgen]
impl Client {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Self {
        let zero_bytes: [u8; 32] = [0; 32];

        Self {
            ephemeral_key_pair: PrivatePublicKeyPair {
                private_key: None,
                public_key: PublicKey::from(zero_bytes)
            },
            shared_secret: None,
        }
    }

    #[wasm_bindgen]
    pub fn initialise_session(&mut self) -> InitSessionMessage {
        self.ephemeral_key_pair = generate_private_public_key_pair();

        InitSessionMessage {
            client_ephemeral_public_key: self.ephemeral_key_pair.public_key
        }
    }

    #[wasm_bindgen]
    // Steps 15 - 20 of the Goldberg 2012 paper.
    pub fn handle_response_from_server(
        &mut self,
        server_certificate: &Certificate,
        msg: &InitSessionResponse,
    ) -> bool {
        println!("Client:");

        // Step 18: Compute the shared secret.
        let mut buffer: Vec<u8> = Vec::new();

        // ECDH Client private ephemeral * server static public key
        let taken_private_key = self.ephemeral_key_pair.private_key.take().unwrap();
        let mut ecdh_result_1 = taken_private_key.diffie_hellman(&msg.server_ephemeral_public_key).to_bytes().to_vec();
        // println!("[Debug] ECDH result 1: {:?}", ecdh_result_1);
        buffer.append(&mut ecdh_result_1);

        // ECDH Client private ephemeral * server ephemeral public Key
        let mut ecdh_result_2 = taken_private_key.diffie_hellman(&server_certificate.public_key).to_bytes().to_vec();
        // println!("[Debug] ECDH result 2: {:?}", ecdh_result_2);
        buffer.append(&mut ecdh_result_2);

        // Server id
        buffer.append(&mut server_certificate.server_id.as_bytes().to_vec());

        // Client ephemeral public
        buffer.append(&mut self.ephemeral_key_pair.public_key.as_bytes().to_vec());

        // Server ephemeral public
        buffer.append(&mut msg.server_ephemeral_public_key.as_bytes().to_vec());

        // "ntor" string identifier
        buffer.append(&mut "ntor".as_bytes().to_vec());

        // Instantiate and run hashing function
        let mut hasher = Sha256::new();
        hasher.update(buffer);
        let sha256_hash = hasher.finalize();
        let sha256_hash: &[u8; 32] = match sha256_hash.as_slice().try_into() {
            Ok(array_ref) => array_ref,
            Err(_) => {
                panic!("Invalid sha256 hash length");
            }
        };

        let secret_key_prime = &sha256_hash[0..16];
        println!("[Debug] Client secret key prime: {:?}", secret_key_prime);

        let secret_key = &sha256_hash[16..];

        // Step 19: Compute HMAC (t_b in the paper)

        let mut buffer: Vec<u8> = Vec::new();
        buffer.append(&mut server_certificate.server_id.as_bytes().to_vec());
        buffer.append(&mut msg.server_ephemeral_public_key.as_bytes().to_vec());
        buffer.append(&mut self.ephemeral_key_pair.public_key.as_bytes().to_vec());
        buffer.append(&mut "ntor".as_bytes().to_vec());
        buffer.append(&mut "server".as_bytes().to_vec());

        let mut hmac_hash = Hmac::<Sha256>::new_from_slice(&buffer).unwrap();
        hmac_hash.update(secret_key_prime);
        let computed_t_hash = hmac_hash.finalize().into_bytes().to_vec();

        // assert that computed_t_b_hash equals t_hash generated by server
        if computed_t_hash == msg.t_hash {
            self.shared_secret = Some(secret_key.to_vec());

            println!("Shared secret:");
            println!("{:?}\n", secret_key);
            true
        } else {
            println!("Failed to verify the shared secret: try again bro.");
            false
        }
    }

    #[wasm_bindgen]
    pub fn encrypt(&self, data: Vec<u8>) -> Result<EncryptedData, JsError> {
        console::debug_1(&format!("encrypt input: {:?}", data).into());
        if let Some(key) = self.shared_secret.clone() {
            let mut encrypt_key = key.clone(); // fixme use key derivation
            encrypt_key.extend(key.clone());
            // println!("Shared key: {}", hex::encode(key.clone()));
            return match common::encrypt(encrypt_key, data) {
                Ok((nonce, encrypted)) => {
                    console::debug_1(&format!("encrypted: {:?}", encrypted).into());
                    Ok(EncryptedData {
                        nonce: nonce.to_vec(),
                        encrypted: encrypted
                    })
                },
                Err(err) => Err(JsError::new(err))
            }
        }
        Err(JsError::new("no encryption key found"))
    }

    #[wasm_bindgen]
    pub fn decrypt(&self, nonce: Vec<u8>, data: Vec<u8>) -> Result<Vec<u8>, JsError> {
        if let Some(key) = self.shared_secret.clone() {
            let mut decrypt_key = key.clone();
            decrypt_key.extend(key.clone());
            console::debug_1(&format!("decrypt input: {:?}, nonce: {:?}", data, nonce).into());

            return match TryInto::<[u8; 12]>::try_into(nonce) {
                Ok(nonce12) => {
                    return match common::decrypt(nonce12, decrypt_key, data) {
                        Ok(decrypted) => {
                            console::debug_1(&format!("decrypted: {:?}", decrypted).into());
                            Ok(decrypted)
                        },
                        Err(err) => Err(JsError::new(err))
                    }
                },
                Err(err) => {
                    console::error_1(&format!("invalid nonce: {:?}", err).into());
                    Err(JsError::new("invalid nonce"))
                }
            }
        }
        Err(JsError::new("no decryption key found"))
    }
}

#[wasm_bindgen(getter_with_clone)]
pub struct EncryptedData {
    pub nonce: Vec<u8>,
    pub encrypted: Vec<u8>
}